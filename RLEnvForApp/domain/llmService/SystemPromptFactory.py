import re

class SystemPromptFactory:
    @staticmethod
    def get(selector) -> str:
        if selector == "is_submit_button":
            return "<<SYS>>You are an AI web crawler assistant. Follow the user requirements carefully and The user will give you some web elements. Please answer it is a form submitting button. Please only say yes or no.<<\SYS>>[INST]{prompt}[/INST]"
        elif selector == "is_form_submitted":
            # The following sentences describe the changes that occurred before and after the form submission. Please determine whether the submission was successful based on these descriptions. Analyze whether any error messages or pop-up error windows appeared and whether the webpage content changed. Definition of successful submission: A submission is considered successful only if both of the following conditions are met: 1. The webpage content changes after submission. 2. No error messages or pop-up error windows are shown. Output Format: 1. Only return yes or no as plain text. 2. Do not include quotation marks, code block formatting, or special characters. 3. Correct format: yes; Incorrect format examples: "yes" or 'yes' Special Rule: If no descriptions are provided, assume there were no changes, so the correct answer is no.
            return "<<SYS>>The following sentences describe the changes that occurred before and after the form submission. Please determine whether the submission was successful based on these descriptions. Analyze whether any error messages or pop-up error windows appeared and whether the webpage content changed. Definition of successful submission: A submission is considered successful only if both of the following conditions are met: 1. The webpage content changes after submission. 2. No error messages or pop-up error windows are shown. Output Format: 1. Only return yes or no as plain text. 2. Do not include quotation marks, code block formatting, or special characters. 3. Correct format: yes; Incorrect format examples: \"yes\" or 'yes' Special Rule: If no descriptions are provided, assume there were no changes, so the correct answer is no <<\SYS>>[INST]{prompt}[/INST]"
        elif selector == "input_field_category_number":
            return "<<SYS>>The label from web form belong to which category. Please only say the index of the category. category: [ \"first name\", \"last name\", \"email\", \"gender\", \"string\", \"user name\", \"full name\", \"postal code\", \"store name\", \"phone number\", \"street address\", \"city\", \"state\", \"province\", \"region\", \"number\", \"country\", \"display name\", \"address\", \"suburb\", \"company name\", \"card number\", \"expiration date\", \"CVV\", \"date\", ]<<\SYS>>[INST]{prompt}[/INST]"
        elif selector == "select_option":
            # Please determine the most appropriate value for the select field based on the form title, select field, feedback, and the previous fields with values. Selection Criteria: 1. Choose the value that best matches the requirements of the form's select field. Output Format: 1. Return only one selected value as plain text. 2. Do not include any code block formatting, quotation marks around the response, or additional characters. 3. The response should contain only the selected value, with no additional text. 4. Example of the correct output format: Correct: \"US\" Incorrect: \"\"US\"\" (extra quotation marks) Special Rule: If the select field is related to website language selection, return value that correspond to \"English\" or \"Chinese\".
            return "<<SYS>>Please determine the most appropriate value for the select field based on the form title, select field, feedback, and the previous fields with values. Selection Criteria: 1. Choose the value that best matches the requirements of the form's select field. Output Format: 1. Return only one selected value as plain text. 2. Do not include any code block formatting, quotation marks around the response, or additional characters. 3. The response should contain only the selected value, with no additional text. 4. Example of the correct output format: Correct: \"US\" Incorrect: \"\"US\"\" (extra quotation marks) Special Rule: If the select field is related to website language selection, return value that correspond to \"English\" or \"Chinese\" <<\SYS>>[INST]{prompt}[/INST]"
        elif selector == "get_checkbox_state":
            # Please return the most appropriate checkbox selection based on the form title, checkbox field, feedback, alert, and the previous fields with values. Selection Criteria: 1. Choose \"True\" if the checkbox should be checked based on the form requirements. 2. Choose \"False\" if the checkbox should not be checked. 3. Consider the provided previous fields with values as criteria for determining the appropriate checkbox selection. 4. Take feedback and alerts into account if they indicate validation errors or conditions affecting checkbox selection. Output Format: 1. Return only \"True\" or \"False\" as plain text. 2. Do not include quotation marks around the response unless \"True\" or \"False\" is the actual output. 3. Do not use code block formatting or any additional characters. 4. Example of the correct output format: Correct: \"True\" Incorrect: \"\"True\"\" (extra quotation marks)
            return "<<SYS>>Please determine whether the following checkbox field should be checked, based on the form title, checkbox label and name, any validation feedback, and the previously filled fields. Decision Criteria: 1. Return \"True\" if the checkbox is required to be checked according to the form's constraints or feedback. 2. Return \"False\" if the checkbox should remain unchecked or is optional. 3. Feedback messages may indicate constraints such as \"cannot be unchecked\" or \"must be enabled\". Interpret such messages accordingly. 4. Consider the previously filled fields and values to determine if the checkbox should be selected based on user role, permissions, or form logic. Output Format: 1. Return only **True** or **False** as plain text. 2. Do not include quotation marks, code block formatting, or any additional characters—only output a single word: True or False. 3. Example of correct output: True <<\SYS>>[INST]{prompt}[/INST]"
        elif selector == "get_input_value":
            # Please generate the most suitable value based on the form title, input field, feedback, and the previous fields with values. Criterion: Generate the value that best meets the requirements of the form's input field, including constraints implied by feedback and alerts. Output format: 1. Return the input value as a string. 2. The response must be a single, plain text string with no additional characters. 3. Do not include any code block formatting, quotation marks, or special characters. 4. Example of the correct output format:  Correct: \"Tom\" Incorrect: \"\"Tom\"\" or \"'Tom'\" Inputs:{prompt}
            return "<<SYS>>Please generate the most suitable value based on the form title, input field, feedback, and the previous fields with values. Criterion: Generate the value that best meets the requirements of the form's input field, including constraints implied by feedback. Output format: 1. Return the input value as a string. 2. The response must be a single, plain text string with no additional characters. 3. Do not include any code block formatting, quotation marks, or special characters. 4. Example of the correct output format: Correct: \"Tom\" Incorrect: \"\"Tom\"\" or \"'Tom'\" <<\SYS>>[INST]{prompt}[/INST]"
        elif selector == "select_data_faker":
            # Please select the most suitable method from the provided options based on the form title, input field, feedback, and the previously filled fields. Selection Criteria: Choose the method that best satisfies all applicable requirements, including: 1. The semantic intent of the current input field (e.g., if the field label is "Country", use location-related methods). 2. Constraints implied by the feedback (e.g., errors like "invalid format"). 3. Warnings in the alert (e.g., "too short" or "unacceptable characters"). 4. Context provided by the previously filled fields and their values. Output format: 1. Return the input value as a string. 2. The response must be a single, plain text string with no additional characters. 3. Do not include any code block formatting, quotation marks, or special characters. 4. Example of the correct output format:  Correct: \"Tom\" Incorrect: \"\"Tom\"\" or \"'Tom'\" Methods: [faker.zipcode(),faker.city(),faker.street_name(),faker.secondary_address(),faker.county(),faker.country(),faker.country_code(),faker.state(),faker.state_abbr(),faker.latitude(),faker.longitude(),faker.street_address(),faker.email(),faker.user_name(),faker.password(),faker.sentence(),faker.word(),faker.paragraph(),faker.first_name(),faker.last_name(),faker.name(),faker.phone_number(),faker.date_this_century(),faker.company(),faker.company(),faker.random_number(),faker.city_suffix(),faker.credit_card_number(),faker.credit_card_expire(),faker.credit_card_security_code(),faker.vin(),faker.license_plate(),faker.building_number(),faker.postcode(),faker.street_suffix(),faker.aba(),faker.bank_country(),faker.bban(),faker.iban(),faker.swift(),faker.swift11(),faker.swift8(),faker.ean(),faker.ean13(),faker.ean8(),fake.localized_ean(),fake.localized_ean13(),fake.localized_ean8(),faker.color(),faker.color_hsl(),faker.color_hsv(),faker.color_name(),faker.color_rgb(),faker.hex_color(),faker.rgb_color(),faker.rgb_css_color(),faker.safe_color_name(),faker.safe_hex_color(),faker.bs(),faker.catch_phrase(),faker.company_suffix(),faker.credit_card_full,faker.credit_card_provider(),faker.cryptocurrency(),faker.cryptocurrency_code(),faker.cryptocurrency_name(),faker.currency(),faker.currency_code(),faker.currency_name(),faker.currency_symbol(),faker.pricetag(),faker.am_pm(),faker.century(),faker.date(),faker.date_between(),faker.date_between_dates(),faker.date_object(),faker.date_of_birth(),faker.date_this_decade(),faker.date_this_month(),faker.date_this_year(),faker.date_time(),faker.date_time_ad(),faker.date_time_between(),faker.date_time_between_dates(),faker.date_time_this_century(),faker.date_time_this_decade(),faker.date_time_this_month(),faker.date_time_this_year(),faker.day_of_month(),faker.day_of_week(),faker.future_date(),faker.future_datetime(),faker.iso8601(),faker.month(),faker.month_name(),faker.past_date(),faker.past_datetime(),faker.pytimezone(),faker.time(),faker.time_delta(),faker.time_object(),faker.time_series(),faker.timezone(),faker.unix_time(),faker.year(),faker.emoji(),faker.file_extension(),faker.file_name(),faker.file_path(),faker.mime_type(),faker.unix_device(),faker.unix_partition(),faker.coordinate(),faker.latlng(),faker.local_latlng(),faker.location_on_land(),faker.ascii_company_email(),faker.ascii_email(),faker.ascii_free_email(),faker.ascii_safe_email(),faker.company_email(),faker.dga(),faker.domain_name(),faker.domain_word(),faker.free_email(),faker.free_email_domain(),faker.hostname(),faker.http_method(),faker.http_status_code(),faker.iana_id(),faker.image_url(),faker.ipv4(),faker.ipv4_network_class(),faker.ipv4_private(),faker.ipv4_public(),faker.ipv6(),faker.mac_address(),faker.nic_handle(),faker.nic_handles(),faker.port_number(),faker.ripe_id(),faker.safe_domain_name(),faker.safe_email(),faker.slug(),faker.tld(),faker.uri(),faker.uri_extension(),faker.uri_page(),faker.uri_path(),faker.url(),faker.isbn10(),faker.isbn13(),faker.job(),faker.job_female(),faker.job_male(),faker.get_words_list(),faker.paragraphs(),faker.sentences(),faker.text(),faker.texts(),faker.words(),faker.binary(),faker.boolean(),faker.csv(),faker.dsv(),faker.fixed_width(),faker.json(),faker.json_bytes(),faker.md5(),faker.null_boolean(),faker.psv(),faker.sha1(),faker.sha256(),faker.tar(),faker.tsv(),faker.uuid4(),faker.xml(),faker.zip(),faker.passport_dob(),faker.passport_number(),faker.passport_owner(),faker.first_name_female(),faker.first_name_male(),faker.first_name_nonbinary(),faker.language_name(),faker.last_name_female(),faker.last_name_male(),faker.last_name_nonbinary(),faker.name_female(),faker.name_male(),faker.name_nonbinary(),faker.prefix(),faker.prefix_female(),faker.prefix_male(),faker.prefix_nonbinary(),faker.suffix(),faker.suffix_female(),faker.suffix_male(),faker.suffix_nonbinary(),faker.country_calling_code(),faker.msisdn(),faker.profile(),faker.simple_profile(),faker.bothify(),faker.hexify(),faker.language_code(),faker.lexify(),faker.locale(),faker.numerify(),faker.random_choices(),faker.random_digit(),faker.random_digit_above_two(),faker.random_digit_not_null(),faker.random_digit_not_null_or_empty(),faker.random_digit_or_empty(),faker.random_element(),faker.random_elements(),faker.random_int(),faker.random_letter(),faker.random_letters(),faker.random_lowercase_letter(),faker.random_sample(),faker.random_uppercase_letter(),faker.randomize_nb_elements(),faker.sbn9(),faker.ssn(),faker.android_platform_token(),faker.chrome(),faker.firefox(),faker.internet_explorer(),faker.ios_platform_token(),faker.linux_platform_token(),faker.linux_processor(),faker.mac_platform_token(),faker.mac_processor(),faker.opera(),faker.safari(),faker.user_agent(),faker.windows_platform_token(),faker.enum(),faker.pydecimal(),faker.pydict(),faker.pyfloat(),faker.pyint(),faker.pyiterable(),faker.pylist(),faker.pyobject(),faker.pyset(),faker.pystr(),faker.pystr_format(),faker.pystruct(),faker.pytuple()]
            # methods = "[faker.zipcode(),faker.city(),faker.street_name(),faker.secondary_address(),faker.county(),faker.country(),faker.country_code(),faker.state(),faker.state_abbr(),faker.latitude(),faker.longitude(),faker.street_address(),faker.email(),faker.user_name(),faker.password(),faker.sentence(),faker.word(),faker.paragraph(),faker.first_name(),faker.last_name(),faker.name(),faker.phone_number(),faker.date_this_century(),faker.company(),faker.company(),faker.random_number(),faker.city_suffix(),faker.credit_card_number(),faker.credit_card_expire(),faker.credit_card_security_code(),faker.vin(),faker.license_plate(),faker.building_number(),faker.postcode(),faker.street_suffix(),faker.aba(),faker.bank_country(),faker.bban(),faker.iban(),faker.swift(),faker.swift11(),faker.swift8(),faker.ean(),faker.ean13(),faker.ean8(),fake.localized_ean(),fake.localized_ean13(),fake.localized_ean8(),faker.color(),faker.color_hsl(),faker.color_hsv(),faker.color_name(),faker.color_rgb(),faker.hex_color(),faker.rgb_color(),faker.rgb_css_color(),faker.safe_color_name(),faker.safe_hex_color(),faker.bs(),faker.catch_phrase(),faker.company_suffix(),faker.credit_card_full,faker.credit_card_provider(),faker.cryptocurrency(),faker.cryptocurrency_code(),faker.cryptocurrency_name(),faker.currency(),faker.currency_code(),faker.currency_name(),faker.currency_symbol(),faker.pricetag(),faker.am_pm(),faker.century(),faker.date(),faker.date_between(),faker.date_between_dates(),faker.date_object(),faker.date_of_birth(),faker.date_this_decade(),faker.date_this_month(),faker.date_this_year(),faker.date_time(),faker.date_time_ad(),faker.date_time_between(),faker.date_time_between_dates(),faker.date_time_this_century(),faker.date_time_this_decade(),faker.date_time_this_month(),faker.date_time_this_year(),faker.day_of_month(),faker.day_of_week(),faker.future_date(),faker.future_datetime(),faker.iso8601(),faker.month(),faker.month_name(),faker.past_date(),faker.past_datetime(),faker.pytimezone(),faker.time(),faker.time_delta(),faker.time_object(),faker.time_series(),faker.timezone(),faker.unix_time(),faker.year(),faker.emoji(),faker.file_extension(),faker.file_name(),faker.file_path(),faker.mime_type(),faker.unix_device(),faker.unix_partition(),faker.coordinate(),faker.latlng(),faker.local_latlng(),faker.location_on_land(),faker.ascii_company_email(),faker.ascii_email(),faker.ascii_free_email(),faker.ascii_safe_email(),faker.company_email(),faker.dga(),faker.domain_name(),faker.domain_word(),faker.free_email(),faker.free_email_domain(),faker.hostname(),faker.http_method(),faker.http_status_code(),faker.iana_id(),faker.image_url(),faker.ipv4(),faker.ipv4_network_class(),faker.ipv4_private(),faker.ipv4_public(),faker.ipv6(),faker.mac_address(),faker.nic_handle(),faker.nic_handles(),faker.port_number(),faker.ripe_id(),faker.safe_domain_name(),faker.safe_email(),faker.slug(),faker.tld(),faker.uri(),faker.uri_extension(),faker.uri_page(),faker.uri_path(),faker.url(),faker.isbn10(),faker.isbn13(),faker.job(),faker.job_female(),faker.job_male(),faker.get_words_list(),faker.paragraphs(),faker.sentences(),faker.text(),faker.texts(),faker.words(),faker.binary(),faker.boolean(),faker.csv(),faker.dsv(),faker.fixed_width(),faker.json(),faker.json_bytes(),faker.md5(),faker.null_boolean(),faker.psv(),faker.sha1(),faker.sha256(),faker.tar(),faker.tsv(),faker.uuid4(),faker.xml(),faker.zip(),faker.passport_dob(),faker.passport_number(),faker.passport_owner(),faker.first_name_female(),faker.first_name_male(),faker.first_name_nonbinary(),faker.language_name(),faker.last_name_female(),faker.last_name_male(),faker.last_name_nonbinary(),faker.name_female(),faker.name_male(),faker.name_nonbinary(),faker.prefix(),faker.prefix_female(),faker.prefix_male(),faker.prefix_nonbinary(),faker.suffix(),faker.suffix_female(),faker.suffix_male(),faker.suffix_nonbinary(),faker.country_calling_code(),faker.msisdn(),faker.profile(),faker.simple_profile(),faker.bothify(),faker.hexify(),faker.language_code(),faker.lexify(),faker.locale(),faker.numerify(),faker.random_choices(),faker.random_digit(),faker.random_digit_above_two(),faker.random_digit_not_null(),faker.random_digit_not_null_or_empty(),faker.random_digit_or_empty(),faker.random_element(),faker.random_elements(),faker.random_int(),faker.random_letter(),faker.random_letters(),faker.random_lowercase_letter(),faker.random_sample(),faker.random_uppercase_letter(),faker.randomize_nb_elements(),faker.sbn9(),faker.ssn(),faker.android_platform_token(),faker.chrome(),faker.firefox(),faker.internet_explorer(),faker.ios_platform_token(),faker.linux_platform_token(),faker.linux_processor(),faker.mac_platform_token(),faker.mac_processor(),faker.opera(),faker.safari(),faker.user_agent(),faker.windows_platform_token(),faker.enum(),faker.pydecimal(),faker.pydict(),faker.pyfloat(),faker.pyint(),faker.pyiterable(),faker.pylist(),faker.pyobject(),faker.pyset(),faker.pystr(),faker.pystr_format(),faker.pystruct(),faker.pytuple()]"
            # method_names = re.findall(r"faker\.([a-zA-Z0-9_]+)\(", methods)
            # print("Methods found in the string:")
            # print(method_names)
            methods = "['zipcode', 'city', 'street_name', 'secondary_address', 'county', 'country', 'country_code', 'state', 'state_abbr', 'latitude', 'longitude', 'street_address', 'email', 'user_name', 'password', 'sentence', 'word', 'paragraph', 'first_name', 'last_name', 'name', 'phone_number', 'date_this_century', 'company', 'company', 'random_number', 'city_suffix', 'credit_card_number', 'credit_card_expire', 'credit_card_security_code', 'vin', 'license_plate', 'building_number', 'postcode', 'street_suffix', 'aba', 'bank_country', 'bban', 'iban', 'swift', 'swift11', 'swift8', 'ean', 'ean13', 'ean8', 'color', 'color_hsl', 'color_hsv', 'color_name', 'color_rgb', 'hex_color', 'rgb_color', 'rgb_css_color', 'safe_color_name', 'safe_hex_color', 'bs', 'catch_phrase', 'company_suffix', 'credit_card_provider', 'cryptocurrency', 'cryptocurrency_code', 'cryptocurrency_name', 'currency', 'currency_code', 'currency_name', 'currency_symbol', 'pricetag', 'am_pm', 'century', 'date', 'date_between', 'date_between_dates', 'date_object', 'date_of_birth', 'date_this_decade', 'date_this_month', 'date_this_year', 'date_time', 'date_time_ad', 'date_time_between', 'date_time_between_dates', 'date_time_this_century', 'date_time_this_decade', 'date_time_this_month', 'date_time_this_year', 'day_of_month', 'day_of_week', 'future_date', 'future_datetime', 'iso8601', 'month', 'month_name', 'past_date', 'past_datetime', 'pytimezone', 'time', 'time_delta', 'time_object', 'time_series', 'timezone', 'unix_time', 'year', 'emoji', 'file_extension', 'file_name', 'file_path', 'mime_type', 'unix_device', 'unix_partition', 'coordinate', 'latlng', 'local_latlng', 'location_on_land', 'ascii_company_email', 'ascii_email', 'ascii_free_email', 'ascii_safe_email', 'company_email', 'dga', 'domain_name', 'domain_word', 'free_email', 'free_email_domain', 'hostname', 'http_method', 'http_status_code', 'iana_id', 'image_url', 'ipv4', 'ipv4_network_class', 'ipv4_private', 'ipv4_public', 'ipv6', 'mac_address', 'nic_handle', 'nic_handles', 'port_number', 'ripe_id', 'safe_domain_name', 'safe_email', 'slug', 'tld', 'uri', 'uri_extension', 'uri_page', 'uri_path', 'url', 'isbn10', 'isbn13', 'job', 'job_female', 'job_male', 'get_words_list', 'paragraphs', 'sentences', 'text', 'texts', 'words', 'binary', 'boolean', 'csv', 'dsv', 'fixed_width', 'json', 'json_bytes', 'md5', 'null_boolean', 'psv', 'sha1', 'sha256', 'tar', 'tsv', 'uuid4', 'xml', 'zip', 'passport_dob', 'passport_number', 'passport_owner', 'first_name_female', 'first_name_male', 'first_name_nonbinary', 'language_name', 'last_name_female', 'last_name_male', 'last_name_nonbinary', 'name_female', 'name_male', 'name_nonbinary', 'prefix', 'prefix_female', 'prefix_male', 'prefix_nonbinary', 'suffix', 'suffix_female', 'suffix_male', 'suffix_nonbinary', 'country_calling_code', 'msisdn', 'profile', 'simple_profile', 'bothify', 'hexify', 'language_code', 'lexify', 'locale', 'numerify', 'random_choices', 'random_digit', 'random_digit_above_two', 'random_digit_not_null', 'random_digit_not_null_or_empty', 'random_digit_or_empty', 'random_element', 'random_elements', 'random_int', 'random_letter', 'random_letters', 'random_lowercase_letter', 'random_sample', 'random_uppercase_letter', 'randomize_nb_elements', 'sbn9', 'ssn', 'android_platform_token', 'chrome', 'firefox', 'internet_explorer', 'ios_platform_token', 'linux_platform_token', 'linux_processor', 'mac_platform_token', 'mac_processor', 'opera', 'safari', 'user_agent', 'windows_platform_token', 'enum', 'pydecimal', 'pydict', 'pyfloat', 'pyint', 'pyiterable', 'pylist', 'pyobject', 'pyset', 'pystr', 'pystr_format', 'pystruct', 'pytuple']"
            template = f"<<SYS>>Please select the most suitable method from the provided options based on the form title, input field, feedback, and the previously filled fields. Selection Criteria: Choose the method that best satisfies all applicable requirements, including: 1. The semantic intent of the current input field (e.g., if the field label is \"Country\", use location-related methods). 2. Constraints implied by the feedback (e.g., errors like \"invalid format\" or \"too short\"). 3. Context provided by the previously filled fields and their values. Output format: 1. Return the input value as a string. 2. The response must be a single, plain text string with no additional characters. 3. Do not wrap the output in code block (```) or any other formatting. Return only plain text dictionary. 4. Example of the correct output format: Correct: \"color\" Incorrect: \"faker.color()\" or \"'color'\" Methods: {methods}<<\SYS>>"
            return template + "[INST]{prompt}[/INST]"
        elif selector == "get_feedback_and_location":
            # extract_feedback_template = """ The following sentences describe the new elements that appeared after the form submission. Based on the provided fields, the URLs before and after submission, form information, and the new elements, determine whether any feedback occurs. Output Format: 1. If there is any feedback, return a dictionary where: - The key is the XPath of the field where the feedback appears. - The value is the corresponding feedback message. 2. If no feedback occurs, return an empty dictionary. 3. Do not format the response as a Python code block. 4. Example output: {{ \"//input[@name='email']\": \"Please enter a valid email address.\", \"//input[@name='phone']\": \"Please enter a valid phone number.\" }}
            return "<<SYS>Based on the provided fields and the newly added or updated webpage elements after the form submission, extract any feedback messages that appear. **Important Instructions**: 1. Feedback messages must originate only from the newly added or updated webpage elements after the form submission. 2. Each feedback message must be clearly associated with at least one field from the provided fields, based on XPath or field context. 3. A single feedback message may apply to multiple fields if it explicitly refers to multiple fields (e.g., “Not a valid email and date”). 4. Do not infer feedback from unrelated elements or from generic content that has no clear link to a specific field. 5. If the feedback message includes technical or constraint-like language, do not simplify it into vague terms like “not valid” or “incorrect format”. Instead: - Preserve the numerical limits and structure if present. - Translate it into a clear, human-readable format that still reflects the specific constraint. Output Format: 1. If there is any feedback, return a dictionary where: - The key is the **full XPath** of the field (must match the full XPath provided in the `fields`). - The value is the specific, relevant feedback message. 2. If no feedback occurs, return an empty dictionary. 3. Do not wrap the output in code block (```) or any other formatting. Return only plain text dictionary. 4. Example output: {{ \"/html/body/div/div/div[1]/div/div[2]/form/div[1]/input\": \"Feedback Message\", \"/html/body/div/div/div[1]/div/div[2]/form/div[2]/input\": \"Feedback Message\" }}<<\SYS>>[INST]{prompt}[/INST]"
        elif selector == "filter_feedback":
            # Based on the currently observed feedback messages, the previously recorded feedback messages, the provided fields, and the newly added or updated webpage elements after form submission, determine which feedback messages are valid. Invalid feedback messages commonly exhibit one or both of the following characteristics: * They are unrelated to any existing field in the form (i.e., no direct mapping to the provided XPath). * Their meaning significantly deviates from previously recorded feedback for the same field. When multiple feedback messages are associated with the same XPath: * If their meanings are semantically consistent or complementary, merge them into a single, comprehensive message. * If the current message is more precise or stricter in describing the input requirement, replace the previous message. **Note**: 1. You should consider the new or updated webpage elements, the currently observed feedback messages, and all previously encountered feedbacks in this form session. 2. If the same feedback message appears again on the same XPath, compare the messages to determine which better captures the required input semantics. 3. If different feedback messages appear on the same XPath, compare their semantics: * If semantically similar, keep the more precise one. * If semantically different but both are valid, combine them into one string separated by a semicolon. Output Format: 1. Return a dictionary where: * The key is the full XPath of the field (must match exactly with the full XPath in the fields). * The value is the final feedback message. 2. If no feedback should be retained, return an empty dictionary. 3. Do not format the response as a Python code block or JSON block. 4. Example output: { "/html/body/div/form/div[1]/input": "Please enter a valid first name.", "/html/body/div/form/div[2]/input": "The phone number must be numeric; The phone number must contain exactly 10 digits." } Inputs: currently observed feedback: {current_feedback} previously recorded feedback: {previous feedbacks} provided fields: {fields} newly added or updated webpage elements: {new_or_updated_elements}
            return "<<SYS>>Based on the currently observed feedback messages, the previously recorded feedback messages, the provided fields, and the newly added or updated webpage elements after form submission, determine which feedback messages are valid. Invalid feedback messages commonly exhibit one or both of the following characteristics: * They are unrelated to any existing field in the form (i.e., no direct mapping to the provided XPath). * Their meaning significantly deviates from previously recorded feedback for the same field. When multiple feedback messages are associated with the same XPath: * If their meanings are semantically consistent or complementary, merge them into a single, comprehensive message. * If the current message is more precise or stricter in describing the input requirement, replace the previous message. **Note**: 1. You should consider the new or updated webpage elements, the currently observed feedback messages, and all previously encountered feedbacks in this form session. 2. If the same feedback message appears again on the same XPath, compare the messages to determine which better captures the required input semantics. 3. If different feedback messages appear on the same XPath, compare their semantics: * If semantically similar, keep the more precise one. * If semantically different but both are valid, combine them into one string separated by a semicolon. 4. If previous feedback and the current feedback have the feedback message in different xpath, just keep it in if the previous feedback xpath are exist in the given field. 5. Even if a previously recorded feedback message is not observed in the current feedbacks, it should still be retained as long as its XPath exists in the current list of provided fields. This accounts for the possibility that the user has already addressed the issue, and the feedback is temporarily suppressed on the page. 6. If a field (XPath) has no associated or relevant feedback message—either in current or previous feedbacks—exclude it from the output. Do not generate placeholder values such as \"Unknown\", \"\", or \"Null\". Output Format: 1. Return a dictionary where: * The key is the full XPath of the field (must match exactly with the full XPath in the fields). * The value is the final feedback message. 2. If no feedback should be retained, return an empty dictionary. 3. Do NOT include entries where the value is null, 'null', None, 'None', Unknown, or \"\". These must be filtered out completely. 4. Do not wrap the output in code block (```) or any other formatting. Return only plain text dictionary. 5. Example output: {{ \"/html/body/div/form/div[1]/input\": \"Please enter a valid first name.\", \"/html/body/div/form/div[2]/input\": \"The phone number must be numeric; The phone number must contain exactly 10 digits.\" }} <<\SYS>>[INST]{prompt}[/INST]"
            # Chain of thought ver
            # You are tasked with filtering web form feedback messages. Your goal is to retain only valid and useful feedback for each form field, based on the provided information. You are given: - `current_feedbacks`: feedback messages shown after form submission. - `previous_feedbacks`: earlier feedback messages recorded in the same session. - `fields`: a list of valid XPath fields from the current form. - `new_elements`: new or updated elements on the webpage. Please perform the following steps: Step 1: Analyze each XPath in the current feedbacks. - If its XPath is **not in the fields**, discard it. - If its value is **null, empty, or meaningless**, discard it. - If the same XPath appears in both current and previous feedbacks, compare them: - If semantically similar, keep the **more informative or stricter** one. - If semantically different but both are valid, **merge with semicolon (;)**. Step 2: For each previous feedback: - If its XPath still exists in `fields`, and it's not already overwritten by current feedback, **keep it**. - This ensures we preserve temporarily hidden messages that may still be relevant. Step 3: Discard any XPath with no associated or relevant message in both current and previous feedbacks. 🧠 Please first explain your reasoning for each XPath. 🎯 Then, output the final filtered dictionary **only after this line**: `Final Answer:` Format the output as a standard Python dictionary, without any code block formatting or extra explanation. Example format: Final Answer: {"/html/body/div/form/div[1]/input": "Please enter a valid name."}
            # return "<<SYS>>You are tasked with filtering web form feedback messages. Your goal is to retain only valid and useful feedback for each form field, based on the provided information. You are given: - `current_feedbacks`: feedback messages shown after form submission. - `previous_feedbacks`: earlier feedback messages recorded in the same session. - `fields`: a list of valid XPath fields from the current form. - `new_elements`: new or updated elements on the webpage. Please perform the following steps: Step 1: Analyze each XPath in the current feedbacks. - If its XPath is **not in the fields**, discard it. - If its value is **null, empty, or meaningless**, discard it. - If the same XPath appears in both current and previous feedbacks, compare them: - If semantically similar, keep the **more informative or stricter** one. - If semantically different but both are valid, **merge with semicolon (;)**. Step 2: For each previous feedback: - If its XPath still exists in `fields`, and it's not already overwritten by current feedback, **keep it**. - This ensures we preserve temporarily hidden messages that may still be relevant. Step 3: Discard any XPath with no associated or relevant message in both current and previous feedbacks. Please first explain your reasoning for each XPath. Then, output the final filtered dictionary **only after this line**: `Final Answer:` Format the output as a standard Python dictionary, without any code block formatting or extra explanation. Example format: Final Answer: {{\"/html/body/div/form/div[1]/input\": \"Please enter a valid name.\"}}<<\SYS>>[INST]{prompt}[/INST]"
        raise ValueError(f"Invalid selector: {selector}")

